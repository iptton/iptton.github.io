所有 AI 应用都离不开 prompt 和现有的外部工具调用，而这两者的本质是**对现有的工作流程进行描述并让 AI 自动串连**。

实现 AI 应用需要解决以下问题

- 梳理并清晰描述当前工作流程
- 提供与此项工作完成相关的工具

这是一个完成流水线工作所需要的步骤！一个良好的流水线应该是这样的：

- 工作流程不会有模凌两可的步骤
- 工具之前有清晰的职责区分，完成同一任务不会有多个工具（工具功能之间是正交的）

但现实世界不是这样的，*条条大路通罗马* 是更普遍的现象，举个编程相关的例子，假设编程助手提供了命令行工具，也提供了 ide 相关的编辑文件能力，当 AI 判断需要修改一个文件时，它有 N 条路可实现，因为命令行工具是一个**几乎可以完成所有工作的万能工具**。

实现一个任务的最佳路径是需要经验判断的，而这正是区分有经验者和新手的重要指标，有经验者可以高效准确地完成任务，而新手则有不确定的试错路径，其完成质量和时间都是不可控的。在我们初入职场时，评估一项任务的完成时间，通常都是错的，也正是这原因。

那么 AI 有没办法掌握这些经验呢？答案是有的，AI 可以通过大量的历史数据来学习这些经验，但这需要大量的训练数据和时间。但现在最大的问题不是 AI 的能力，而是我们是否能提供足够的训练数据来让 AI 学习这些经验。这些经验通常是隐性的，甚至连人类都无法清晰地描述出来。

我们需要将这些隐性经验转化为显性经验，这样 AI 才能学习到这些经验。

在编程以外的领域有没类似的问题？有的，比如让机器人学会走路，制定奖励机制让它不断试错，直到学会走路。这个对编程有没参考意义或者说，编程有没可能实现类似的奖励机制？这里的难点在于，编程本身就是一个*条条大路通罗马* 的过程，而不是一个确定的过程。实现一个功能有千万种方法，其过程也是不确定的，我们并没有一个明确的办法能判断一个方法或过程是最优的。它不像走路，是有一个清晰的评判标准：能直立走路就是成功，不能走路就是失败。编程的评判标准是模糊的，甚至是主观的。我们无法给出一个明确的标准来判断一个方法或过程是最优的。行走就是成功了，走得越快越好。编程的评判标准是模糊的，甚至是主观的，比如代码是否优雅、是否易读、是否高效等等，这些都是模糊的标准。我们很难给出一个明确的标准来判断一个方法或过程是最优的。

到现在为止，让 LLM 判断代码是否优雅都还是一个难题，这个难题的**根源是训练的数据里并没有太多关于优雅代码的样本。**

